%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Classification with \solasote}
\label{S:classify}

\solasote's individuals are roughly classified on the grounds of the entity types described previously. For instance, we may obviously ask whether \uri{lang:Java} is a (software) language:

\sparql{javaOfTypeLanguage}

\noindent
Evaluation of this query literally returns `true':

\completeOutput{javaOfTypeLanguage}

\noindent
A more fine-grained classification is also supported on the grounds of a class hierarchy with the entity types as root types. These extra classes are called `classifiers'. For instance, \uri{lang:Java} is of the following (classifier) types:

\completeOutput{typesOfJava}

\noindent
The (classifier) types of an individual can be retrieved like this:

\sparql{typesOfJava}

\noindent
As the query clarifiers, classifier types can be explicitly selected by testing for the extra type \uri{onto:Classifier} of those classes, thereby not confusing them with general types of the ontology---such as \uri{onto:Language} or \uri{Entity}. The class(ifier) hierarchy can also be queried in itself---without starting from individuals. For instance, this is how we ask for the supertypes of the classifier

\sparql{supertypesOfOoProgrammingLanguage}

\completeOutput{supertypesOfOoProgrammingLanguage}

\noindent
This is how we query for all individuals with a certain classifier; in this case, we are interested in all OO programming languages:

\sparql{instancesOfOoProgrammingLanguage}

\noindent
These are some OO programming languages:

\partialOutput{7}{instancesOfOoProgrammingLanguage}

\solasote's approach towards classification makes one specific assumption.  For each classifier, there is a corresponding concept (\uri{onto:Concept}) of the same name modulo different prefixes (`onto' for classifieres, `concept' for concepts). Whether or not a concept has an associated classifier depends on the fact whether the concept is actually used for classification.

In \S\ref{S:entities}, we had queried for `popular' concepts regardless of whether they are (associated with) classifiers. Here is a similar query, which specifically focuses on `popular' classifiers:

\sparql{classifiers}

\noindent
In the query, we use a predicate `classifies' to look up the association between classifier and concept. Here are the first few classifiers returned by the query:

\partialOutputTabular{{l|l}}{\textbf{concept} & \textbf{headline}}{7}{classifiers}
%|

\noindent
Clearly, this list overlaps with the ranking of popular concepts overall; see again \S\ref{S:entities}. For comparison, here is query for `popular' non-classifier concepts:

\sparql{nonClassifiers}

\partialOutputTabular{{l|l}}{\textbf{concept} & \textbf{headline}}{7}{nonClassifiers}
%|

\sparql{baseTypeSubClassing}

\completeOutputTabular{{l|l}}{\textbf{subtype} & \textbf{supertype}}{baseTypeSubClassing}
%|

\sparql{externalTypes}

\completeOutputTabular{{l|l}}{\textbf{subtype} & \textbf{supertype}}{externalTypes}
%|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
