%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Classification with \solasote}
\label{S:classify}

\solasote's individuals are roughly classified on the grounds of the entity types described previously. For instance, we may obviously ask whether \uri{lang:Java} is a (software) language:

\sparql{javaOfTypeLanguage}

\noindent
Evaluation of this query literally returns `true':

\completeOutput{javaOfTypeLanguage}

\noindent
A more fine-grained classification is also supported on the grounds of a class hierarchy with the entity types as root types. These extra classes are called `classifiers'. For instance, \uri{lang:Java} is of the following (classifier) types:

\completeOutput{typesOfJava}

\noindent
The (classifier) types of an individual can be retrieved like this:

\sparql{typesOfJava}

\noindent
As the query clarifiers, classifier types can be explicitly selected by testing for the extra type \uri{onto:Classifier} of those classes, thereby not confusing them with general types of the ontology---such as \uri{onto:Language} or \uri{Entity}. The class(ifier) hierarchy can also be queried in itself---without starting from individuals. For instance, this is how we ask for the supertypes of the classifier

\sparql{supertypesOfOoProgrammingLanguage}

\completeOutput{supertypesOfOoProgrammingLanguage}

\noindent
This is how we query for all individuals with a certain classifier; in this case, we are interested in all OO programming languages:

\sparql{ooProgrammingLanguage}

\noindent
These are some OO programming languages:

\partialOutput{7}{ooProgrammingLanguage}

\solasote's approach towards classification makes one specific assumption.  For each classifier, there is a corresponding concept (\uri{onto:Concept}) of the same name modulo different prefixes (`onto' for classifieres, `concept' for concepts). Whether or not a concept has an associated classifier depends on the fact whether the concept is actually used for classification.

In \S\ref{S:entities}, we had queried for `popular' concepts regardless of whether they are (associated with) classifiers. Here is a similar query, which specifically focuses on `popular' classifiers:

\sparql{classifiers}

\noindent
In the query, we use a predicate `classifies' to look up the association between classifier and concept. Here are the first few classifiers returned by the query:

\partialOutputTabular{{l|l}}{\textbf{concept} & \textbf{headline}}{7}{classifiers}
%|

\noindent
Clearly, this list overlaps with the ranking of popular concepts overall; see again \S\ref{S:entities}. For comparison, here is query for `popular' non-classifier concepts:

\sparql{nonClassifiers}

\partialOutputTabular{{l|l}}{\textbf{concept} & \textbf{headline}}{7}{nonClassifiers}
%|

At this point, we have discussed \solasote's entity types (rooted in
\uri{onto:Entity} and \solasote's classification types forming a class
hierarchy rooted by the entity types with individuals as
instances. \solasote{} uses yet a few extra `base types' to capture
commonalities of entity types in certain contexts. Here is a list of
these types and the corresponding subClassOf relationships:

\completeOutputTabular{{l|l}}{\textbf{type} & \textbf{comment}}{baseTypes}
%|

\completeOutputTabular{{l|l}}{\textbf{subtype} & \textbf{supertype}}{baseTypeSubClassing}
%|

\noindent
For instance, both a software technology and a contribution (i.e., an
implementation of \ooo{}'s system) can be regarded as a `software
system'.  The idea is that these base types are convenient in setting
up \solasote's properties, as discussed in more detail in
\S\ref{S:properties}. For instance, both a technology and a
contribution may be said to be `developed by' a person. For
completeness' sake, the list of base types and the corresponding
subClassOf relationships can be retrieved from \solasote's triplestore
as follows:

\sparql{baseTypes}

\sparql{baseTypeSubClassing}

\noindent
Last but not least, \solasote{} also leverages external types, i.e.,
types of other ontologies. In fact, besides RDF and RDFS, \solasote{}
currently only uses these FOAF types:

\completeOutputTabular{{l|l}}{\textbf{subtype} & \textbf{supertype}}{externalTypes}
%|

\noindent
The following query results in the list shown above:

\sparql{externalTypes}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
