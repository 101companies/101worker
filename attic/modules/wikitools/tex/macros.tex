\newcommand{\LanguageMetaHeadline}{[[Generic programming]] in [[Language:Haskell]] with [[SYB]]}
\newcommand{\LanguageMetaLanguages}{* [[Language:Haskell]] including [[SYB]]-related extensions}
\newcommand{\LanguageMetaTechnologies}{* [[Technology:GHCi]]}
\newcommand{\LanguageMetaFeatures}{* [[101feature:Tree structure]]
* [[101feature:Type hierarchy]]
* [[101feature:Graph structure]]
* [[101feature:Type-driven query]]
* [[101feature:Type-driven transformation]]
* [[101feature:Structure-driven query]]
* [[101feature:Global invariant]]
* [[101feature:Serialization]]}
\newcommand{\LanguageMetaMotivation}{The implementation demonstrates [[generic programming]] in [[Language:Haskell]] using [[SYB]] style. Generic programming is useful in so far that several operations of the 101companies features involve traversal over  nested data. For instance, totaling all salaries requires the location of salary subterms at all levels in a given company term. Accordingly, operations for totaling and cutting salaries are implemented as [[generic function]]s that traverse over the company structure while type-specific cases detect employees and access their salaries. (It happens that the original publication on [[SYB]] used these generic programming samples for motivation.) The resulting code is considerably more concise, when compared to a conservative style of functional programming; see [[101implementation:haskell]]. Additional operations are implemented to exercise [[SYB]] for different idioms of query or transformation and to address additional structural concerns; see the implementations of [[101feature:Structure-driven query]], [[101feature:Graph structure]], and [[101feature:Structure-driven query]].}
\newcommand{\LanguageMetaIllustration}{The data model for companies uses a data type ''SubUnit'' to have a common base concept for departments and employees; it also uses an optional ''Mentor'' component to associate mentees with mentors "by name". In this manner some of non-basic, structure-related features can be exercised:

\lstinputlisting[xleftmargin=5pt, language=haskell" source="Company.hs]{\texgen/sources/WV6F2X6ELN.src}

Several of the operations on companies can be implemented in a very concise manner based on the [[SYB]] style of generic programming. For instance, the operation for totaling salaries simply extracts all floats from the given term and reduces them by addition:

\lstinputlisting[xleftmargin=5pt, language=haskell" source="Total.hs]{\texgen/sources/AAJWE2BI8B.src}}
\newcommand{\LanguageMetaArchitecture}{The implementation is highly modular in terms of the mapping of features to modules. 

Structure-related features:
* [[101feature:Tree structure]]: ''Company.hs''
* [[101feature:Type hierarchy]]: ''Company.hs''
* [[101feature:Graph structure]]: ''Company.hs'' and ''Mentoring.hs''

Behavior-related features:
* [[101feature:Type-driven query]]: ''Total.hs''
* [[101feature:Type-driven transformation]]: ''Cut.hs''
* [[101feature:Structure-driven query]]: ''Depth.hs''
* [[101feature:Global invariant]]: ''Precedence.hs''

Module "Deriving.hs" hosts "deriving" clauses for the type classes "Eq", ''Read", ''Show'', ''Typeable'', and ''Data''
of the data types for companies. In this manner, structural equality, [[closed serialization]], and [[SYB]] style of generic programming are enabled.

Module ''Main.hs'' collects a few test scenarios.}
\newcommand{\LanguageMetaUsage}{The Haskell module ''Main'' has to be consulted with GHCi, and the ''main'' function has to be applied so that output for the test scenarios is produced. The ''expected'' output is available through the file ''baseline''. There is a ''Makefile'' with a target ''test'' for [[test automation]].}
\newcommand{\LanguageMetaContributors}{* [[101contributor:Ralf L\"{a}mmel|Ralf L\"{a}mmel]] ([[:Category:101developer|''developer'']])}
