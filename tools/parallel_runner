#!/usr/bin/perl
use strict;
use warnings;
use Cwd qw(abs_path);
use File::Basename;
use File::Slurp qw(slurp);
use Getopt::Long;
use Graph;
use JSON;
use POSIX qw(strftime);


our $path = (dirname dirname abs_path $0) . '/modules';
GetOptions('modules=s' => \$path);
$path =~ s{/$}{};


my $modules;
eval { $modules = decode_json scalar slurp "../configs/$ARGV[0]" };
die $! if $!;


my $graph = Graph->new;
for my $module (@$modules) {
    $graph->add_vertex($module);
    my $deps = load_dependencies($module);
    $graph->add_edge($_, $module) for @$deps;
}
die 'Cyclic dependency: ' . $graph->find_a_cycle if $graph->has_a_cycle;


our %processes;

while ($graph->vertices) {
    my %roots = map { $_ => undef } $graph->vertices;
    delete $roots{$_->[1]} for $graph->edges;
    delete $roots{$_}      for values %processes;

    while (my ($module) = each %roots) {
        my $pid = fork // die $!;
        if ($pid) {
            $processes{$pid} = $module;
            write_log("$module started with PID $pid");
        } else {
            exec "cd $path/$module; timeout -s KILL 1h make >module.log 2>&1";
        }
    }

    my $pid = wait;
    die 'Fix this if it ever happens' if ($pid == -1);
    my $done = delete $processes{$pid};
    write_log("$done exited with code $?");
    write_log('Still running: ', join ' ', values %processes);
    $graph->delete_vertex($done);
}


sub write_log {
    print strftime('[%Y-%m-%d %H:%M:%S] ', gmtime), @_, "\n";
}


sub load_dependencies {
    my ($module) = (@_);

    my $file = "$path/$module/module.json";
    my $json;
    eval { $json = slurp $file };
    warn "$module ($file): $!\n" if $!;

    if (!$json) {
        print STDERR "Can't read $file, assuming no dependencies for $module\n";
        return [];
    }

    my $deps = {};
    eval { $deps = decode_json $json || {} };
    warn "$module ($file): $!\n" if $!;

    if (!$deps->{dependencies}) {
        print STDERR "No dependencies found for $module, assuming none\n";
    }
    $deps->{dependencies};
}
